package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type Generator struct{}

func NewGenerator() *Generator {
	return &Generator{}
}

func (g *Generator) GenerateDependencyFiles(baseDir string, config *DependencyConfig) error {
	// Create a map from layer name to path for easier lookup
	layerPaths := make(map[LayerName]LayerPath)
	for _, layer := range config.Layers {
		layerPaths[layer.Name] = layer.Path
	}

	// Get module name from go.mod
	parser := NewParser()
	moduleName, err := parser.GetModuleName(filepath.Join(baseDir, "go.mod"))
	if err != nil {
		return err
	}

	// Generate dependency.gen.go for each layer
	for _, layer := range config.Layers {
		if layer.Path == "" {
			continue
		}

		layerDir := filepath.Join(baseDir, layer.Path.String())

		// Check if directory exists, create if not
		if _, err := os.Stat(layerDir); os.IsNotExist(err) {
			err := os.MkdirAll(layerDir, 0755)
			if err != nil {
				return DirectoryCreationError{Path: layerDir, Err: err}
			}
			fmt.Printf("Created directory: %s\n", layerDir)
		}

		// Get all transitive dependencies for this layer
		dependencies := g.GetTransitiveDependencies(layer.Name, config)

		// Generate the dependency file content
		content := g.GenerateDependencyFileContent(layer.Path, dependencies, layerPaths, moduleName)

		// Write the file
		outputPath := filepath.Join(layerDir, "dependency.gen.go")
		err := os.WriteFile(outputPath, []byte(content), 0644)
		if err != nil {
			return FileWriteError{Path: outputPath, Err: err}
		}

		// Format the generated file with go fmt
		cmd := exec.Command("go", "fmt", outputPath)
		if err := cmd.Run(); err != nil {
			return FileFormatError{Path: outputPath, Err: err}
		}

		fmt.Printf("Generated: %s\n", outputPath)
	}

	return nil
}

func (g *Generator) GetTransitiveDependencies(layerName LayerName, config *DependencyConfig) []LayerName {
	visited := make(map[LayerName]bool)
	dependencies := make([]LayerName, 0)

	var collectDependencies func(LayerName)
	collectDependencies = func(currentLayer LayerName) {
		if visited[currentLayer] {
			return
		}
		visited[currentLayer] = true

		// Get direct dependencies of current layer
		directDeps := config.Dependencies[currentLayer]
		for _, dep := range directDeps {
			dependencies = append(dependencies, dep)
			// Recursively collect dependencies of this dependency
			collectDependencies(dep)
		}
	}

	collectDependencies(layerName)

	// Remove duplicates while preserving order
	seen := make(map[LayerName]bool)
	uniqueDeps := make([]LayerName, 0)
	for _, dep := range dependencies {
		if !seen[dep] {
			seen[dep] = true
			uniqueDeps = append(uniqueDeps, dep)
		}
	}

	return uniqueDeps
}

func (g *Generator) GenerateDependencyFileContent(currentLayerPath LayerPath, dependencies []LayerName, layerPaths map[LayerName]LayerPath, moduleName ModuleName) string {
	packageName := g.GetPackageName(currentLayerPath)

	var imports []string
	for _, dep := range dependencies {
		if depPath, exists := layerPaths[dep]; exists && depPath != "" {
			importPath := fmt.Sprintf("%s/%s", moduleName.String(), depPath.String())
			imports = append(imports, fmt.Sprintf("\t_ \"%s\"", importPath))
		}
	}

	content := fmt.Sprintf("// Code generated by go-package-depends. DO NOT EDIT.\n\npackage %s\n", packageName.String())

	if len(imports) > 0 {
		content += "\nimport (\n"
		for _, imp := range imports {
			content += imp + "\n"
		}
		content += ")\n"
	}

	return content
}

func (g *Generator) GetPackageName(layerPath LayerPath) PackageName {
	// Extract package name from path (use the last directory name)
	parts := strings.Split(layerPath.String(), "/")
	packageName := PackageName(parts[len(parts)-1])
	// Note: We don't validate here since this is derived from a validated LayerPath
	return packageName
}
