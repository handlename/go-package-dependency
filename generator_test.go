package main

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateDependencyFileContent(t *testing.T) {
	tests := []struct {
		name            string
		currentPath     LayerPath
		dependencies    []LayerName
		layerPaths      map[LayerName]LayerPath
		moduleName      ModuleName
		expectedContent string
	}{
		{
			name:         "no dependencies",
			currentPath:  LayerPath("domain/entity"),
			dependencies: []LayerName{},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Domain layer"): LayerPath("domain/entity"),
			},
			moduleName: ModuleName("github.com/test/project"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package entity
`,
		},
		{
			name:        "single dependency",
			currentPath: LayerPath("application/usecase"),
			dependencies: []LayerName{
				LayerName("Domain layer"),
			},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Domain layer"):      LayerPath("domain/entity"),
				LayerName("Application layer"): LayerPath("application/usecase"),
			},
			moduleName: ModuleName("github.com/test/project"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package usecase

import (
	_ "github.com/test/project/domain/entity"
)
`,
		},
		{
			name:        "multiple dependencies",
			currentPath: LayerPath("presentation/handler"),
			dependencies: []LayerName{
				LayerName("Application layer"),
				LayerName("Domain layer"),
			},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Domain layer"):       LayerPath("domain/entity"),
				LayerName("Application layer"):  LayerPath("application/usecase"),
				LayerName("Presentation layer"): LayerPath("presentation/handler"),
			},
			moduleName: ModuleName("github.com/test/project"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package handler

import (
	_ "github.com/test/project/application/usecase"
	_ "github.com/test/project/domain/entity"
)
`,
		},
		{
			name:        "nested package path",
			currentPath: LayerPath("infra/database/mysql"),
			dependencies: []LayerName{
				LayerName("Domain layer"),
			},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Domain layer"): LayerPath("domain/entity"),
				LayerName("Infra layer"):  LayerPath("infra/database/mysql"),
			},
			moduleName: ModuleName("github.com/example/app"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package mysql

import (
	_ "github.com/example/app/domain/entity"
)
`,
		},
		{
			name:        "dependency without path",
			currentPath: LayerPath("presentation/handler"),
			dependencies: []LayerName{
				LayerName("Application layer"),
				LayerName("Missing layer"),
			},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Application layer"):  LayerPath("application/usecase"),
				LayerName("Presentation layer"): LayerPath("presentation/handler"),
				// Missing layer has no path
			},
			moduleName: ModuleName("github.com/test/project"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package handler

import (
	_ "github.com/test/project/application/usecase"
)
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			generator := NewGenerator()
			result := generator.GenerateDependencyFileContent(tt.currentPath, tt.dependencies, tt.layerPaths, tt.moduleName)

			assert.Equal(t, tt.expectedContent, result)
		})
	}
}

func TestGetPackageName(t *testing.T) {
	tests := []struct {
		name     string
		path     LayerPath
		expected PackageName
	}{
		{
			name:     "simple path",
			path:     LayerPath("domain/entity"),
			expected: PackageName("entity"),
		},
		{
			name:     "nested path",
			path:     LayerPath("infra/database/mysql"),
			expected: PackageName("mysql"),
		},
		{
			name:     "single directory",
			path:     LayerPath("service"),
			expected: PackageName("service"),
		},
		{
			name:     "deeply nested path",
			path:     LayerPath("presentation/web/api/v1/handler"),
			expected: PackageName("handler"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			generator := NewGenerator()
			result := generator.GetPackageName(tt.path)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetTransitiveDependencies(t *testing.T) {
	tests := []struct {
		name         string
		layerName    LayerName
		config       *DependencyConfig
		expectedDeps []LayerName
	}{
		{
			name:      "no dependencies",
			layerName: LayerName("Domain layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{},
			},
			expectedDeps: []LayerName{},
		},
		{
			name:      "single direct dependency",
			layerName: LayerName("Application layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{
					LayerName("Application layer"): {LayerName("Domain layer")},
				},
			},
			expectedDeps: []LayerName{LayerName("Domain layer")},
		},
		{
			name:      "transitive dependencies",
			layerName: LayerName("Presentation layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{
					LayerName("Presentation layer"): {LayerName("Application layer")},
					LayerName("Application layer"):  {LayerName("Domain layer")},
				},
			},
			expectedDeps: []LayerName{
				LayerName("Application layer"),
				LayerName("Domain layer"),
			},
		},
		{
			name:      "multiple direct dependencies with transitive",
			layerName: LayerName("Infrastructure layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{
					LayerName("Infrastructure layer"): {LayerName("Application layer"), LayerName("Domain layer")},
					LayerName("Application layer"):    {LayerName("Domain layer")},
				},
			},
			expectedDeps: []LayerName{
				LayerName("Application layer"),
				LayerName("Domain layer"),
			},
		},
		{
			name:      "complex dependency chain",
			layerName: LayerName("UI layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{
					LayerName("UI layer"):             {LayerName("Presentation layer")},
					LayerName("Presentation layer"):   {LayerName("Application layer")},
					LayerName("Application layer"):    {LayerName("Domain layer")},
					LayerName("Infrastructure layer"): {LayerName("Domain layer")},
				},
			},
			expectedDeps: []LayerName{
				LayerName("Presentation layer"),
				LayerName("Application layer"),
				LayerName("Domain layer"),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			generator := NewGenerator()
			result := generator.GetTransitiveDependencies(tt.layerName, tt.config)

			assert.Len(t, result, len(tt.expectedDeps))
			assert.Equal(t, tt.expectedDeps, result)
		})
	}
}

func TestGenerateDependencyFiles(t *testing.T) {
	// Create a temporary directory structure
	tmpDir, err := os.MkdirTemp("", "go-package-depends-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	// Create go.mod file
	goModContent := `module github.com/test/integration

go 1.21
`
	goModPath := filepath.Join(tmpDir, "go.mod")
	err = os.WriteFile(goModPath, []byte(goModContent), 0644)
	require.NoError(t, err)

	// Create dependency configuration
	config := &DependencyConfig{
		Layers: []Layer{
			{Name: LayerName("Domain layer"), Path: LayerPath("domain/entity")},
			{Name: LayerName("Application layer"), Path: LayerPath("application/usecase")},
			{Name: LayerName("Presentation layer"), Path: LayerPath("presentation/handler")},
		},
		Dependencies: map[LayerName][]LayerName{
			LayerName("Presentation layer"): {LayerName("Application layer"), LayerName("Domain layer")},
			LayerName("Application layer"):  {LayerName("Domain layer")},
		},
	}

	// Generate dependency files
	generator := NewGenerator()
	err = generator.GenerateDependencyFiles(tmpDir, config)
	require.NoError(t, err)

	// Check that directories were created
	expectedDirs := []string{
		"domain/entity",
		"application/usecase",
		"presentation/handler",
	}

	for _, dir := range expectedDirs {
		dirPath := filepath.Join(tmpDir, dir)
		_, err := os.Stat(dirPath)
		assert.NoError(t, err, "Directory %s should exist", dirPath)
	}

	// Check generated files
	testCases := []struct {
		path            string
		expectedContent string
	}{
		{
			path: "domain/entity/dependency.gen.go",
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package entity
`,
		},
		{
			path: "application/usecase/dependency.gen.go",
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package usecase

import (
	_ "github.com/test/integration/domain/entity"
)
`,
		},
		{
			path: "presentation/handler/dependency.gen.go",
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package handler

import (
	_ "github.com/test/integration/application/usecase"
	_ "github.com/test/integration/domain/entity"
)
`,
		},
	}

	for _, tc := range testCases {
		filePath := filepath.Join(tmpDir, tc.path)
		content, err := os.ReadFile(filePath)
		require.NoError(t, err, "Should be able to read file %s", filePath)
		assert.Equal(t, tc.expectedContent, string(content), "File %s content should match", tc.path)
	}
}

func TestGenerateDependencyFilesNonExistentDir(t *testing.T) {
	// Create a temporary directory structure
	tmpDir, err := os.MkdirTemp("", "go-package-depends-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	// Create go.mod file
	goModContent := `module github.com/test/nested

go 1.21
`
	goModPath := filepath.Join(tmpDir, "go.mod")
	err = os.WriteFile(goModPath, []byte(goModContent), 0644)
	require.NoError(t, err)

	config := &DependencyConfig{
		Layers: []Layer{
			{Name: LayerName("New layer"), Path: LayerPath("new/nested/path")},
		},
		Dependencies: map[LayerName][]LayerName{},
	}

	generator := NewGenerator()
	err = generator.GenerateDependencyFiles(tmpDir, config)
	require.NoError(t, err)

	// Check that the nested directory was created
	nestedDir := filepath.Join(tmpDir, "new/nested/path")
	_, err = os.Stat(nestedDir)
	assert.NoError(t, err, "Nested directory should be created")

	// Check that the dependency file was created
	depFile := filepath.Join(nestedDir, "dependency.gen.go")
	_, err = os.Stat(depFile)
	assert.NoError(t, err, "Dependency file should be created")
}
