package main

import (
	"os"
	"path/filepath"
	"testing"
)

func TestGenerateDependencyFileContent(t *testing.T) {
	tests := []struct {
		name            string
		currentPath     LayerPath
		dependencies    []LayerName
		layerPaths      map[LayerName]LayerPath
		moduleName      ModuleName
		expectedContent string
	}{
		{
			name:         "no dependencies",
			currentPath:  LayerPath("domain/entity"),
			dependencies: []LayerName{},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Domain layer"): LayerPath("domain/entity"),
			},
			moduleName: ModuleName("github.com/test/project"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package entity
`,
		},
		{
			name:        "single dependency",
			currentPath: LayerPath("application/usecase"),
			dependencies: []LayerName{
				LayerName("Domain layer"),
			},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Domain layer"):      LayerPath("domain/entity"),
				LayerName("Application layer"): LayerPath("application/usecase"),
			},
			moduleName: ModuleName("github.com/test/project"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package usecase

import (
	_ "github.com/test/project/domain/entity"
)
`,
		},
		{
			name:        "multiple dependencies",
			currentPath: LayerPath("presentation/handler"),
			dependencies: []LayerName{
				LayerName("Application layer"),
				LayerName("Domain layer"),
			},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Domain layer"):       LayerPath("domain/entity"),
				LayerName("Application layer"):  LayerPath("application/usecase"),
				LayerName("Presentation layer"): LayerPath("presentation/handler"),
			},
			moduleName: ModuleName("github.com/test/project"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package handler

import (
	_ "github.com/test/project/application/usecase"
	_ "github.com/test/project/domain/entity"
)
`,
		},
		{
			name:        "nested package path",
			currentPath: LayerPath("infra/database/mysql"),
			dependencies: []LayerName{
				LayerName("Domain layer"),
			},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Domain layer"): LayerPath("domain/entity"),
				LayerName("Infra layer"):  LayerPath("infra/database/mysql"),
			},
			moduleName: ModuleName("github.com/example/app"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package mysql

import (
	_ "github.com/example/app/domain/entity"
)
`,
		},
		{
			name:        "dependency without path",
			currentPath: LayerPath("presentation/handler"),
			dependencies: []LayerName{
				LayerName("Application layer"),
				LayerName("Missing layer"),
			},
			layerPaths: map[LayerName]LayerPath{
				LayerName("Application layer"):  LayerPath("application/usecase"),
				LayerName("Presentation layer"): LayerPath("presentation/handler"),
				// Missing layer has no path
			},
			moduleName: ModuleName("github.com/test/project"),
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package handler

import (
	_ "github.com/test/project/application/usecase"
)
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			generator := NewGenerator()
			result := generator.GenerateDependencyFileContent(tt.currentPath, tt.dependencies, tt.layerPaths, tt.moduleName)

			if result != tt.expectedContent {
				t.Errorf("Expected:\n%s\nGot:\n%s", tt.expectedContent, result)
			}
		})
	}
}

func TestGetPackageName(t *testing.T) {
	tests := []struct {
		name     string
		path     LayerPath
		expected PackageName
	}{
		{
			name:     "simple path",
			path:     LayerPath("domain/entity"),
			expected: PackageName("entity"),
		},
		{
			name:     "nested path",
			path:     LayerPath("infra/database/mysql"),
			expected: PackageName("mysql"),
		},
		{
			name:     "single directory",
			path:     LayerPath("service"),
			expected: PackageName("service"),
		},
		{
			name:     "deeply nested path",
			path:     LayerPath("presentation/web/api/v1/handler"),
			expected: PackageName("handler"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			generator := NewGenerator()
			result := generator.GetPackageName(tt.path)
			if result != tt.expected {
				t.Errorf("Expected %s, got %s", tt.expected, result)
			}
		})
	}
}

func TestGetTransitiveDependencies(t *testing.T) {
	tests := []struct {
		name         string
		layerName    LayerName
		config       *DependencyConfig
		expectedDeps []LayerName
	}{
		{
			name:      "no dependencies",
			layerName: LayerName("Domain layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{},
			},
			expectedDeps: []LayerName{},
		},
		{
			name:      "single direct dependency",
			layerName: LayerName("Application layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{
					LayerName("Application layer"): {LayerName("Domain layer")},
				},
			},
			expectedDeps: []LayerName{LayerName("Domain layer")},
		},
		{
			name:      "transitive dependencies",
			layerName: LayerName("Presentation layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{
					LayerName("Presentation layer"): {LayerName("Application layer")},
					LayerName("Application layer"):  {LayerName("Domain layer")},
				},
			},
			expectedDeps: []LayerName{
				LayerName("Application layer"),
				LayerName("Domain layer"),
			},
		},
		{
			name:      "multiple direct dependencies with transitive",
			layerName: LayerName("Infrastructure layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{
					LayerName("Infrastructure layer"): {LayerName("Application layer"), LayerName("Domain layer")},
					LayerName("Application layer"):    {LayerName("Domain layer")},
				},
			},
			expectedDeps: []LayerName{
				LayerName("Application layer"),
				LayerName("Domain layer"),
			},
		},
		{
			name:      "complex dependency chain",
			layerName: LayerName("UI layer"),
			config: &DependencyConfig{
				Dependencies: map[LayerName][]LayerName{
					LayerName("UI layer"):             {LayerName("Presentation layer")},
					LayerName("Presentation layer"):   {LayerName("Application layer")},
					LayerName("Application layer"):    {LayerName("Domain layer")},
					LayerName("Infrastructure layer"): {LayerName("Domain layer")},
				},
			},
			expectedDeps: []LayerName{
				LayerName("Presentation layer"),
				LayerName("Application layer"),
				LayerName("Domain layer"),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			generator := NewGenerator()
			result := generator.GetTransitiveDependencies(tt.layerName, tt.config)

			if len(result) != len(tt.expectedDeps) {
				t.Errorf("Expected %d dependencies, got %d", len(tt.expectedDeps), len(result))
				t.Errorf("Expected: %v", tt.expectedDeps)
				t.Errorf("Got: %v", result)
				return
			}

			for i, expected := range tt.expectedDeps {
				if i >= len(result) || result[i] != expected {
					t.Errorf("Dependency %d: expected %s, got %s", i, expected, result[i])
				}
			}
		})
	}
}

func TestGenerateDependencyFiles(t *testing.T) {
	// Create a temporary directory structure
	tmpDir, err := os.MkdirTemp("", "go-package-depends-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create go.mod file
	goModContent := `module github.com/test/integration

go 1.21
`
	goModPath := filepath.Join(tmpDir, "go.mod")
	err = os.WriteFile(goModPath, []byte(goModContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create go.mod: %v", err)
	}

	// Create dependency configuration
	config := &DependencyConfig{
		Layers: []Layer{
			{Name: LayerName("Domain layer"), Path: LayerPath("domain/entity")},
			{Name: LayerName("Application layer"), Path: LayerPath("application/usecase")},
			{Name: LayerName("Presentation layer"), Path: LayerPath("presentation/handler")},
		},
		Dependencies: map[LayerName][]LayerName{
			LayerName("Presentation layer"): {LayerName("Application layer"), LayerName("Domain layer")},
			LayerName("Application layer"):  {LayerName("Domain layer")},
		},
	}

	// Generate dependency files
	generator := NewGenerator()
	err = generator.GenerateDependencyFiles(tmpDir, config)
	if err != nil {
		t.Fatalf("Failed to generate dependency files: %v", err)
	}

	// Check that directories were created
	expectedDirs := []string{
		"domain/entity",
		"application/usecase",
		"presentation/handler",
	}

	for _, dir := range expectedDirs {
		dirPath := filepath.Join(tmpDir, dir)
		if _, err := os.Stat(dirPath); os.IsNotExist(err) {
			t.Errorf("Directory %s was not created", dirPath)
		}
	}

	// Check generated files
	testCases := []struct {
		path            string
		expectedContent string
	}{
		{
			path: "domain/entity/dependency.gen.go",
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package entity
`,
		},
		{
			path: "application/usecase/dependency.gen.go",
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package usecase

import (
	_ "github.com/test/integration/domain/entity"
)
`,
		},
		{
			path: "presentation/handler/dependency.gen.go",
			expectedContent: `// Code generated by go-package-depends. DO NOT EDIT.

package handler

import (
	_ "github.com/test/integration/application/usecase"
	_ "github.com/test/integration/domain/entity"
)
`,
		},
	}

	for _, tc := range testCases {
		filePath := filepath.Join(tmpDir, tc.path)
		content, err := os.ReadFile(filePath)
		if err != nil {
			t.Errorf("Failed to read file %s: %v", filePath, err)
			continue
		}

		if string(content) != tc.expectedContent {
			t.Errorf("File %s content mismatch.\nExpected:\n%s\nGot:\n%s",
				tc.path, tc.expectedContent, string(content))
		}
	}
}

func TestGenerateDependencyFilesNonExistentDir(t *testing.T) {
	// Create a temporary directory structure
	tmpDir, err := os.MkdirTemp("", "go-package-depends-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create go.mod file
	goModContent := `module github.com/test/nested

go 1.21
`
	goModPath := filepath.Join(tmpDir, "go.mod")
	err = os.WriteFile(goModPath, []byte(goModContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create go.mod: %v", err)
	}

	config := &DependencyConfig{
		Layers: []Layer{
			{Name: LayerName("New layer"), Path: LayerPath("new/nested/path")},
		},
		Dependencies: map[LayerName][]LayerName{},
	}

	generator := NewGenerator()
	err = generator.GenerateDependencyFiles(tmpDir, config)
	if err != nil {
		t.Fatalf("Failed to generate dependency files: %v", err)
	}

	// Check that the nested directory was created
	nestedDir := filepath.Join(tmpDir, "new/nested/path")
	if _, err := os.Stat(nestedDir); os.IsNotExist(err) {
		t.Errorf("Nested directory %s was not created", nestedDir)
	}

	// Check that the dependency file was created
	depFile := filepath.Join(nestedDir, "dependency.gen.go")
	if _, err := os.Stat(depFile); os.IsNotExist(err) {
		t.Errorf("Dependency file %s was not created", depFile)
	}
}
