package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateDependencyFileContent(t *testing.T) {
	tests := []struct {
		name         string
		packagePath  LayerPath
		dependencies []LayerPath
		moduleName   ModuleName
		expected     string
	}{
		{
			name:         "package with no dependencies",
			packagePath:  LayerPath("domain/entity"),
			dependencies: []LayerPath{},
			moduleName:   ModuleName("github.com/example/project"),
			expected: `// Code generated by go-package-dependency. DO NOT EDIT.

package entity
`,
		},
		{
			name:        "package with single dependency",
			packagePath: LayerPath("domain/service"),
			dependencies: []LayerPath{
				LayerPath("domain/entity"),
			},
			moduleName: ModuleName("github.com/example/project"),
			expected: `// Code generated by go-package-dependency. DO NOT EDIT.

package service

import (
	_ "github.com/example/project/domain/entity"
)
`,
		},
		{
			name:        "package with multiple dependencies",
			packagePath: LayerPath("app/usecase"),
			dependencies: []LayerPath{
				LayerPath("app/service"),
				LayerPath("domain/entity"),
				LayerPath("domain/service"),
				LayerPath("domain/valueobject"),
			},
			moduleName: ModuleName("github.com/example/project"),
			expected: `// Code generated by go-package-dependency. DO NOT EDIT.

package usecase

import (
	_ "github.com/example/project/app/service"
	_ "github.com/example/project/domain/entity"
	_ "github.com/example/project/domain/service"
	_ "github.com/example/project/domain/valueobject"
)
`,
		},
		{
			name:        "nested package path",
			packagePath: LayerPath("infra/database/mysql"),
			dependencies: []LayerPath{
				LayerPath("domain/entity"),
			},
			moduleName: ModuleName("github.com/example/project"),
			expected: `// Code generated by go-package-dependency. DO NOT EDIT.

package mysql

import (
	_ "github.com/example/project/domain/entity"
)
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			generator := NewGenerator()
			result := generator.GenerateDependencyFileContent(tt.packagePath, tt.dependencies, tt.moduleName)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetDependenciesForPackage(t *testing.T) {
	config := &DependencyConfig{
		Layers: []Layer{
			{
				Name:  LayerName("Domain layer"),
				Order: 1,
				Packages: []Package{
					{Path: LayerPath("domain/entity"), Level: 0},
					{Path: LayerPath("domain/valueobject"), Level: 0},
					{Path: LayerPath("domain/service"), Level: 1},
				},
			},
			{
				Name:  LayerName("Application layer"),
				Order: 2,
				Packages: []Package{
					{Path: LayerPath("app/service"), Level: 0},
					{Path: LayerPath("app/usecase"), Level: 1},
				},
			},
			{
				Name:  LayerName("Presentation layer"),
				Order: 3,
				Packages: []Package{
					{Path: LayerPath("api"), Level: 0},
					{Path: LayerPath("cli"), Level: 0},
				},
			},
			{
				Name:  LayerName("Infra layer"),
				Order: 4,
				Packages: []Package{
					{Path: LayerPath("infra/database"), Level: 0},
					{Path: LayerPath("infra/cache"), Level: 0},
				},
			},
		},
	}

	tests := []struct {
		name          string
		targetPackage Package
		expectedDeps  []LayerPath
		expectNoDeps  bool
	}{
		{
			name:          "domain entity - no dependencies",
			targetPackage: Package{Path: LayerPath("domain/entity"), Level: 0},
			expectedDeps:  []LayerPath{},
			expectNoDeps:  true,
		},
		{
			name:          "domain valueobject - no dependencies",
			targetPackage: Package{Path: LayerPath("domain/valueobject"), Level: 0},
			expectedDeps:  []LayerPath{},
			expectNoDeps:  true,
		},
		{
			name:          "domain service - depends on entity and valueobject",
			targetPackage: Package{Path: LayerPath("domain/service"), Level: 1},
			expectedDeps: []LayerPath{
				LayerPath("domain/entity"),
				LayerPath("domain/valueobject"),
			},
		},
		{
			name:          "app service - depends on domain layer",
			targetPackage: Package{Path: LayerPath("app/service"), Level: 0},
			expectedDeps: []LayerPath{
				LayerPath("domain/entity"),
				LayerPath("domain/valueobject"),
				LayerPath("domain/service"),
			},
		},
		{
			name:          "app usecase - depends on domain layer and app service",
			targetPackage: Package{Path: LayerPath("app/usecase"), Level: 1},
			expectedDeps: []LayerPath{
				LayerPath("domain/entity"),
				LayerPath("domain/valueobject"),
				LayerPath("domain/service"),
				LayerPath("app/service"),
			},
		},
		{
			name:          "api - depends on domain and app layers",
			targetPackage: Package{Path: LayerPath("api"), Level: 0},
			expectedDeps: []LayerPath{
				LayerPath("domain/entity"),
				LayerPath("domain/valueobject"),
				LayerPath("domain/service"),
				LayerPath("app/service"),
				LayerPath("app/usecase"),
			},
		},
		{
			name:          "infra database - depends on all upper layers",
			targetPackage: Package{Path: LayerPath("infra/database"), Level: 0},
			expectedDeps: []LayerPath{
				LayerPath("domain/entity"),
				LayerPath("domain/valueobject"),
				LayerPath("domain/service"),
				LayerPath("app/service"),
				LayerPath("app/usecase"),
				LayerPath("api"),
				LayerPath("cli"),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := config.GetDependenciesForPackage(tt.targetPackage)

			if tt.expectNoDeps {
				assert.Empty(t, result, "Expected no dependencies")
				return
			}

			assert.Len(t, result, len(tt.expectedDeps), "Dependency count mismatch")

			// Convert to sets for comparison (order shouldn't matter in dependencies)
			resultSet := make(map[LayerPath]bool)
			for _, dep := range result {
				resultSet[dep] = true
			}

			expectedSet := make(map[LayerPath]bool)
			for _, dep := range tt.expectedDeps {
				expectedSet[dep] = true
			}

			for expectedDep := range expectedSet {
				assert.True(t, resultSet[expectedDep], "Missing expected dependency: %s", expectedDep)
			}

			for actualDep := range resultSet {
				assert.True(t, expectedSet[actualDep], "Unexpected dependency: %s", actualDep)
			}
		})
	}
}

func TestGetAllPackages(t *testing.T) {
	config := &DependencyConfig{
		Layers: []Layer{
			{
				Name:  LayerName("Domain layer"),
				Order: 1,
				Packages: []Package{
					{Path: LayerPath("domain/entity"), Level: 0},
					{Path: LayerPath("domain/service"), Level: 1},
				},
			},
			{
				Name:  LayerName("Application layer"),
				Order: 2,
				Packages: []Package{
					{Path: LayerPath("app/usecase"), Level: 0},
				},
			},
		},
	}

	packages := config.GetAllPackages()

	expected := []Package{
		{Path: LayerPath("domain/entity"), Level: 0},
		{Path: LayerPath("domain/service"), Level: 1},
		{Path: LayerPath("app/usecase"), Level: 0},
	}

	assert.Len(t, packages, len(expected))

	// Convert to sets for comparison
	actualSet := make(map[LayerPath]Package)
	for _, pkg := range packages {
		actualSet[pkg.Path] = pkg
	}

	for _, expectedPkg := range expected {
		actualPkg, exists := actualSet[expectedPkg.Path]
		assert.True(t, exists, "Missing package: %s", expectedPkg.Path)
		assert.Equal(t, expectedPkg.Level, actualPkg.Level, "Level mismatch for package: %s", expectedPkg.Path)
	}
}

func TestGetPackagesByLayer(t *testing.T) {
	config := &DependencyConfig{
		Layers: []Layer{
			{
				Name:  LayerName("Domain layer"),
				Order: 1,
				Packages: []Package{
					{Path: LayerPath("domain/entity"), Level: 0},
					{Path: LayerPath("domain/service"), Level: 1},
				},
			},
			{
				Name:  LayerName("Application layer"),
				Order: 2,
				Packages: []Package{
					{Path: LayerPath("app/usecase"), Level: 0},
				},
			},
		},
	}

	// Test existing layer
	domainPackages := config.GetPackagesByLayer(LayerName("Domain layer"))
	expected := []Package{
		{Path: LayerPath("domain/entity"), Level: 0},
		{Path: LayerPath("domain/service"), Level: 1},
	}

	assert.Len(t, domainPackages, len(expected))
	for i, expectedPkg := range expected {
		assert.Equal(t, expectedPkg.Path, domainPackages[i].Path)
		assert.Equal(t, expectedPkg.Level, domainPackages[i].Level)
	}

	// Test non-existing layer
	nonExistentPackages := config.GetPackagesByLayer(LayerName("Non-existent layer"))
	assert.Nil(t, nonExistentPackages)
}

func TestGenerateDependencyFiles(t *testing.T) {
	// Create temporary directory
	tmpDir, err := os.MkdirTemp("", "generator-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	// Create go.mod file
	goModContent := `module github.com/test/project

go 1.21
`
	goModPath := filepath.Join(tmpDir, "go.mod")
	err = os.WriteFile(goModPath, []byte(goModContent), 0644)
	require.NoError(t, err)

	config := &DependencyConfig{
		Layers: []Layer{
			{
				Name:  LayerName("Domain layer"),
				Order: 1,
				Packages: []Package{
					{Path: LayerPath("domain/entity"), Level: 0},
					{Path: LayerPath("domain/service"), Level: 1},
				},
			},
			{
				Name:  LayerName("Application layer"),
				Order: 2,
				Packages: []Package{
					{Path: LayerPath("app/usecase"), Level: 0},
				},
			},
		},
	}

	generator := NewGenerator()
	err = generator.GenerateDependencyFiles(tmpDir, config)
	require.NoError(t, err)

	// Check that the correct files were generated
	expectedFiles := []string{
		filepath.Join(tmpDir, "domain/entity/dependency.gen.go"),
		filepath.Join(tmpDir, "domain/service/dependency.gen.go"),
		filepath.Join(tmpDir, "app/usecase/dependency.gen.go"),
	}

	for _, expectedFile := range expectedFiles {
		assert.FileExists(t, expectedFile, "Expected file should exist: %s", expectedFile)

		content, err := os.ReadFile(expectedFile)
		require.NoError(t, err)

		contentStr := string(content)
		assert.Contains(t, contentStr, "// Code generated by go-package-dependency. DO NOT EDIT.")

		// Extract package name from path and verify
		parts := strings.Split(expectedFile, string(filepath.Separator))
		packageName := parts[len(parts)-2] // Get directory name
		assert.Contains(t, contentStr, "package "+packageName)
	}

	// Verify specific content for domain/service (should have dependencies)
	serviceFile := filepath.Join(tmpDir, "domain/service/dependency.gen.go")
	content, err := os.ReadFile(serviceFile)
	require.NoError(t, err)

	contentStr := string(content)
	assert.Contains(t, contentStr, `_ "github.com/test/project/domain/entity"`)

	// Verify specific content for app/usecase (should have dependencies from domain layer)
	usecaseFile := filepath.Join(tmpDir, "app/usecase/dependency.gen.go")
	content, err = os.ReadFile(usecaseFile)
	require.NoError(t, err)

	contentStr = string(content)
	assert.Contains(t, contentStr, `_ "github.com/test/project/domain/entity"`)
	assert.Contains(t, contentStr, `_ "github.com/test/project/domain/service"`)

	// Verify specific content for domain/entity (should have no dependencies)
	entityFile := filepath.Join(tmpDir, "domain/entity/dependency.gen.go")
	content, err = os.ReadFile(entityFile)
	require.NoError(t, err)

	contentStr = string(content)
	assert.NotContains(t, contentStr, "import (")
}
